%!TEX program = lualatex
\documentclass[10pt,mathserif]{beamer}

\usepackage{luatexja}
\usepackage{luatexja-fontspec}
\setmainjfont[
    RawFeature={instance=Regular},
    BoldFont=Noto Sans CJK SC,
    BoldFeatures={RawFeature={instance=Bold}},
]{Noto Sans CJK SC}

\setmonofont[
    RawFeature={instance=Regular},
    BoldFont=Noto Sans Mono,
    BoldFeatures={RawFeature={instance=Bold}},
]{Noto Sans Mono}

\definecolor{xdublue}{RGB}{0,65,130}

\usepackage{listings}
\lstset{
basicstyle=\small\ttfamily,
keywordstyle=\color{xdublue},
numbers=left,
numberstyle=\tiny,
frame=leftline,
tabsize=4
}

\lstdefinestyle{term}
{basicstyle=\ttfamily, numbers=none, frame=single, breaklines=true,
moredelim={[is][keywordstyle]{@@}{@@}}}

\newcommand{\lstcode}[1] { \lstinputlisting[language=C++]{code/#1} }
\newcommand{\lstterm}[1] { \lstinputlisting[style=term]{code/#1} }

\usepackage{ulem}

\usetheme[xdblue]{XDUstyle}

\title{Competitive Programming 101}
\institute{西安电子科技大学程序设计竞赛实训基地}
\author{席若尧}
\date{2021 年 7 月 5 日}
	
\begin{document}%
{\xdbg \frame[plain,noframenumbering]{\titlepage}}

\begin{frame}{内容}
	\tableofcontents[hideallsubsections]
\end{frame}

\section{ICPC 环境简介}
\sectionpage

\begin{frame}{基本认知}
	\begin{itemize}
		\item 程序设计竞赛与竞技体育/电子竞技类似
		\item 决定比赛成绩的因素有：天赋、训练、运气
		\item 不想训练的话也有很多低水平比赛可以打 (校赛，省赛，CSP 等)
		\item 想好好打的话，要对这项比赛有基本的认同感
		\item 尽量避免自视高贵/发表暴论
	\end{itemize}
\end{frame}

\begin{frame}{工作环境}
	\begin{itemize}
		\item Ubuntu GNU/Linux
			\begin{itemize}
				\item 没有 root 权限
			\end{itemize}
		\item GCC
		\item OpenJDK
		\item Python 3 or PyPy 3
		\item Vim, Emacs, Gedit, Code::Blocks 等
	\end{itemize}
\end{frame}

\begin{frame}{团队配合}
	\begin{itemize}
		\item 三人一机
		\item 可以打印代码
		\item 实力 (训练量) 是配合的基础
	\end{itemize}
\end{frame}

\section{程序的行为和编译优化}
\sectionpage

\begin{frame}{现状}
	\begin{itemize}
		\item 本节内容应该是程序设计基础课程的一部分，但是懂的都懂
	\end{itemize}
	\begin{center}
		\includegraphics[width=.3\textwidth]{img/shit2.jpg}
	\end{center}
\end{frame}

\begin{frame}{现状}
	\begin{itemize}
		\item “你不确定的话就写个程序跑一下吧。”
			\pause
		\item 要是化学老师这么教课，实验室早炸上天了
	\end{itemize}
\end{frame}

\begin{frame}{现状}
	\begin{itemize}
		\item “我打了 3 年 OI 还能不知道自己的程序啥行为？”
			\pause
		\item 众所周知 NOIP 不开 \texttt{-O2}
	\end{itemize}
\end{frame}

\begin{frame}{程序的行为}
	C 标准 (\texttt{ISO/IEC 9899:2011} \S 5.1.2.3 p6) 规定，
	程序的\textbf{可观测行为}包括：
	\begin{itemize}
		\item 访问 \texttt{volatile} 变量
		\item 写入文件
		\item 操作交互式输入输出设备
	\end{itemize}
	实现 (在实践中由编译器和运行库组成) 只需要正确实现可观测行为。
	编译器可以在保证可观测行为不变的前提下，通过调整生成的机器代码，
	使得程序变得更小或更快。
\end{frame}

\begin{frame}[fragile]{例}{Hello world}
	\lstcode{hw.cc}
\end{frame}

\begin{frame}[fragile]{例}{Hello World}
	生成的汇编代码根本没有 \texttt{printf}？
	\lstinputlisting[style=term,emph={puts},emphstyle=\color{xdublue}]
	{code/hw.out}
\end{frame}

\begin{frame}[fragile]{例}{取模}
	\lstcode{mod.cc}
\end{frame}

\begin{frame}[fragile]{例}{取模}
	没有除法指令？
	\lstterm{mod.out}
\end{frame}

\begin{frame}[fragile]{例}{取模 (误)}
	\lstcode{mod_bad.cc}
\end{frame}

\begin{frame}[fragile]{例}{取模 (误)}
	\lstinputlisting[style=term,emph={idivl},emphstyle=\color{xdublue}]
	{code/mod_bad.out}
	\begin{itemize}
		\item 看上去简洁很多？
		\item 悲剧的是，这条除法指令比之前的一大堆加起来都慢。
		\item 实际做题时，因为忘加这个 \texttt{const}，可能引入
			$50\%$ 至 $200\%$ 的时间代价。
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{例}{strstr (Linux)}
	\lstcode{strstr.cc}
	\begin{itemize}
		\item 这题不用 KMP 能过？
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{例}{strstr (Linux)}
	\lstterm{strstr.out}
	\begin{itemize}
		\item 在 Linux 上跑得飞快
		\item Glibc 的 \lstinline{strstr} 是时间
			$\mathcal{O}(n + m)$，空间 $\mathcal{O}(1)$ 的高级算法，
			而且是高度优化的手写汇编代码
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{例}{strlen (运气好)}
	\lstcode{strlen-1.cc}
	\begin{itemize}
		\item 目测是 $\mathcal{O}(n^2)$ 的，会 TLE？
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{例}{strlen (运气好)}
	\lstterm{strlen-1.out}
	\begin{itemize}
		\item 然而跑得飞快
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{例}{strlen (运气差)}
	\lstcode{strlen-2.cc}
	\begin{itemize}
		\item 就改个大小写，不会出大问题吧
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{例}{strlen (运气差)}
	\lstterm{strlen-2.out}
	\begin{itemize}
		\item 人都没了
		\item 编译器的能力是有极限的\sout{，所以我不做编译器辣！}
	\end{itemize}
\end{frame}

\begin{frame}{几类行为}
	\begin{itemize}
		\item 标准定义的行为
		\item 实现定义的行为 (implementation-defined)
		\item 未指定行为 (unspecified)
		\item 未定义行为 (undefined)
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{实现定义的行为}
	标准要求实现作出一致的选择。
	\begin{itemize}
		\item 一个典型例子是 \lstinline{rand} 函数生成随机数的规则
			(包括但不限于 \lstinline{RAND_MAX} 的值)，
			这在 2020 -- 2021 ICPC 区域赛南京站产生了显著的影响。
		\item 另一个例子是 FFT 等场合常用的卡常技巧
			\lstinline{a += M & (a >> 31);}，它的目的是将
			$[-M, M)$ 中的整数模 $M$ (变为 $[0, M)$ 中的整数)。
			其正确性依赖于 GCC 规定负数右移按算术右移规则进行，
			如果更换编译器则可能出错。
	\end{itemize}
\end{frame}

\begin{frame}{未指定行为}
	标准未作说明，允许实现随意选择。
	\begin{itemize}
		\item 几乎所有程序都会涉及未指定行为，例如函数调用时，
			对其参数求值的顺序就是未指定的。
		\item 但是，如果你的 (比赛用) 程序的输出依赖于某个未指定行为，
			那么很有可能产生难以调试的 bug。
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{例}
	\lstcode{unspecified.cc}
	\begin{itemize}
		\item 如果实现先对后一个 \lstinline{read()} 求值怎么办？
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{修复}
	\lstcode{unspecified-fix.cc}
	\begin{itemize}
		\item 语言标准要求初始化列表中的元素必须从左到右求值。
	\end{itemize}
\end{frame}

\begin{frame}{未定义行为}
	\begin{itemize}
		\item 语法错误
		\item 语义错误
			\begin{itemize}
				\item 违反约束条件 (constraint)：要求编译器将其视为编译错误
				\item 其他：未定义行为，实现可以干任何事！
			\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{未定义行为}
	\begin{itemize}
		\item “什么都可能发生”
		\item 在没有操作系统或操作系统欠缺安全机制时，甚至能够损毁硬件
		\item 在比赛中可能产生“本地测不出来 bug，但交上去就错”的问题
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{例}{函数无返回值}
	\begin{columns}[t]
		\begin{column}{.5\textwidth}
			\begin{itemize}
				\item 一类十分值得注意的未定义行为是，
					在非 \lstinline{void} 函数中，程序流程到达函数尾。
				\item 注意此时无论是否实际使用了该函数的返回值，
					只要程序执行到函数尾，都是未定义行为。
				\item 在编译器执行优化时，它可能假设
					“程序永远不会执行到该函数的尾部”，
					从而产生更加奇怪的行为。
				\item \textbf{老资格的 OI 选手}需要特别注意！
			\end{itemize}
		\end{column}
		\begin{column}{.5\textwidth}
			\lstcode{no-return.cc}
		\end{column}
	\end{columns}
\end{frame}

\begin{frame}{没有银弹}
	\begin{center}
	\begin{tikzpicture}[fill=xdublue]
		\def\outbox{(-2, -2) rectangle(3, 3)}
		\def\firstcircle{(0, 0) circle(1)}
		\def\secondcircle{(1, 0) circle(1)}
		\def\thirdcircle{(0.5, 1) circle(1)}
		\fill[even odd rule]
		\outbox \firstcircle \secondcircle \thirdcircle;
		\draw \firstcircle node[left] {安全};
		\draw \secondcircle node[right] {高效};
		\draw \thirdcircle node[above] {易用};
		\draw \firstcircle node[shift={(-0.1,0.6)}]
		{\textcolor{white}{慢}};
		\draw \secondcircle node[shift={(0.1,0.6)}]
		{\textcolor{white}{\tiny 不安全}};
		\draw \thirdcircle node[shift={(0,-1.2)}]
		{\textcolor{white}{难学}};
		\draw \thirdcircle node[shift={(0,-0.6)}] {???};
		\draw \outbox node[shift={(-1,-1)}] {\textcolor{white}{屑}};
	\end{tikzpicture}
	\end{center}
\end{frame}

\section{程序调试技巧}
\sectionpage

\begin{frame}{子标题}{副标题}
	测试页
\end{frame}

{\xdbg%末页致谢
\begin{frame}[plain,noframenumbering]
 \finalpage{{\huge 感谢观看！}}
\end{frame}}

\end{document}
